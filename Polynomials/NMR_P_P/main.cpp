/*
** Преобразование многочлена — кратные корни в простые.
** Зависимости:
** GCF_PP_P
** DER_P_P
** DIV_PP_P
** (то есть при создании данного модуля должны использоваться функции этих модулей).
**
** В случае неимения решения модуля (в соответствующем проекте) на данный момент, прошу
** использовать в коде прототипы функций, что описал в header файле (все функции называются
** примерно также, как и модули).
**
** А как появится решение, можете скопировать код функции соответствующего проекта для
** своей  программы и протестировать ее на различные входные данные. С технологией
** тестирования определюсь позднее.
**
** Требование: оформлять функции (порядок аргументов и выходные данные) и использовать
** зависимые модули(если таковые есть) в точности с прототипом header файла
** (это сделано для стандартизации работы проекта).
**
** !!! В случае отсутствия у модуля каких-либо зависимостей необходимо сделать его
** как можно скорее и отправить на проверку !!!
**
** Желаю успехов, боец
** (-_-)
*/
#include <cassert>
#include "head.h"

LongP NMRofPtoP(const LongP& Polynom)
{
    if (degPtoN(Polynom) < 2)
    {
        return Polynom;
    }
    // если есть корень кратности k, то он есть в НОД многочлена и его производной
    // в виде кратности k - 1. Простой же корень не входит в этот НОД. Доказательство простое.
    LongP result = { 0 };

    LongP derp = derPtoP(Polynom);

    result = GCFofPPtoP(Polynom , derPtoP(Polynom));

    if (degPtoN(result) == 0)
    {
        return Polynom;
    }

    // в НОД может входить посторонный коэф. в виде m(x-1)^(k-1)*...
    // это получается из-за того, что кратность не гарантирует отсутствие констант в записи
    // поэтому используем ранее использованную функцию по выносу НОД и НОК (при этом изменяя сам аргумент
    // в виде полинома).
    facPtoQ(result);

    // блок кода, инвертирующий знаки, если старший коэффициент отрицателен.
    if (ledPtoQ(result).num.sign == 1)
    {
        for (int i = 0; i <= result.deg; ++i)
            result.odds[i].num = mulZMtoZ(result.odds[i].num);
    }

    return divPPtoP(Polynom , result);
}

void tests()
{
    //x^6+9x^5+32x^4+56x^3+48x^2+16x кратность корня -2 равна 4
    LongP test1 = { 0 };
    test1.deg = 6;
    test1.odds[0] = { {0, 0,{0}}, { 0,{1} }, };
    test1.odds[1] = { {0, 1,{6,1}}, { 0,{1} }, };
    test1.odds[2] = { {0, 1,{8,4}}, { 0,{1} }, };
    test1.odds[3] = { {0, 1,{6,5}}, { 0,{1} }, };
    test1.odds[4] = { {0, 1,{2,3}}, { 0,{1} }, };
    test1.odds[5] = { {0, 0,{9}}, { 0,{1} }, };
    test1.odds[6] = { {0, 0,{1}}, { 0,{1} }, };
    // x^3+3x^2+2x = x(x+2)(x+1) кратность корней простая
    LongP res = { 0 };
    res.deg = 3;
    res.odds[0] = { {0, 0,{0}}, { 0,{0} }, };
    res.odds[1] = { {0, 0,{2}}, { 0,{1} }, };
    res.odds[2] = { {0, 0,{3}}, { 0,{1} }, };
    res.odds[3] = { {0, 0,{1}}, { 0,{1} }, };

    assert(comPPtoB(NMRofPtoP(test1) , res));

    //5x^5+65x^4+330x^3+810x^2+945x+405 кратность корня -3 равна 4
    test1 = { 0 };
    test1.deg = 5;
    test1.odds[0] = { {0, 2,{5,0,4}}, { 0,{1} }, };
    test1.odds[1] = { {0, 2,{5,4,9}}, { 0,{1} }, };
    test1.odds[2] = { {0, 2,{0,1,8}}, { 0,{1} }, };
    test1.odds[3] = { {0, 2,{0,3,3}}, { 0,{1} }, };
    test1.odds[4] = { {0, 1,{5,6}}, { 0,{1} }, };
    test1.odds[5] = { {0, 0,{5}}, { 0,{1} }, };
    // 5x^2+20x+15 = 5(x+3)(x+1) кратность корней простая
    res = { 0 };
    res.deg = 2;
    res.odds[0] = { {0, 1,{5,1}}, { 0,{1} }, };
    res.odds[1] = { {0, 1,{0,2}}, { 0,{1} }, };
    res.odds[2] = { {0, 0,{5}}, { 0,{1} }, };

    LongP result = NMRofPtoP(test1);

    assert(comPPtoB(NMRofPtoP(test1) , res));

    //-3x^4+27x^3-63x^2+57x-18 кратность корня 1 равна 3
    test1 = { 0 };
    test1.deg = 4;
    test1.odds[0] = { {1, 1,{8,1}}, { 0,{1} }, };
    test1.odds[1] = { {0, 1,{7,5}}, { 0,{1} }, };
    test1.odds[2] = { {1, 1,{3,6}}, { 0,{1} }, };
    test1.odds[3] = { {0, 1,{7,2}}, { 0,{1} }, };
    test1.odds[4] = { {1, 0,{3}}, { 0,{1} }, };
    // -3x^2+21x-18 = -3(x-6)(x-1) кратность корней простая
    res = { 0 };
    res.deg = 2;
    res.odds[0] = { {1, 1,{8,1}}, { 0,{1} }, };
    res.odds[1] = { {0, 1,{1,2}}, { 0,{1} }, };
    res.odds[2] = { {1, 0,{3}}, { 0,{1} }, };

    result = NMRofPtoP(test1);

    assert(comPPtoB(NMRofPtoP(test1) , res));
}

int main()
{
    tests();
    return 0;
}
