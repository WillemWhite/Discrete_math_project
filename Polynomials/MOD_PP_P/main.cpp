/*
** Остаток от деления многочлена на многочлен при делении с остатком
** Зависимости:
** DIV_PP_P
** MUL_PP_P
** SUB_PP_P
** (то есть при создании данного модуля должны использоваться функции этих модулей).
**
** В случае неимения решения модуля (в соответствующем проекте) на данный момент, прошу
** использовать в коде прототипы функций, что описал в header файле (все функции называются
** примерно также, как и модули).
**
** А как появится решение, можете скопировать код функции соответствующего проекта для
** своей  программы и протестировать ее на различные входные данные. С технологией
** тестирования определюсь позднее.
**
** Требование: оформлять функции (порядок аргументов и выходные данные) и использовать
** зависимые модули(если таковые есть) в точности с прототипом header файла
** (это сделано для стандартизации работы проекта).
**
** !!! В случае отсутствия у модуля каких-либо зависимостей необходимо сделать его
** как можно скорее и отправить на проверку !!!
**
** Желаю успехов, боец
** (-_-)
*/
#include <cassert>
#include "head.h"

LongP modPPtoP(const LongP& first , const LongP& second)
{
    LongP quotient = divPPtoP(first , second);

    return subPPtoP(first , mulPPtoP(second , quotient));
}

int main() {
    LongP first = { 4,
    {
        {
            {1, 2, {0, 5, 2}},
            {0, {1}}
        },
        {
            {1, 2, {0, 5, 2}},
            {0, {1}}
        },
        {
            {0, 2, {0, 1, 5,}},
            {0, {1}}
        },
        {
            {0, 2, {5, 2, 1}},
            {0, {1}}
        },
        {
            {0, 2, {0, 5, 2}},
            {0, {1}}
        }
    } };
    LongP second = { 3,
    {
        {
            {0, 0, {1}},
            {0, {1}}
        },
        {
            {0, 0, {1}},
            {0, {1}}
        },
        {
            {0, 0, {1}},
            {0, {1}}
        },
        {
            {0, 0, {1}},
            {0, {1}}
        }
    } };

    LongP mod = modPPtoP(first , second);

    LongP res = { 2,
    {
        {
            {1, 2, {5, 2, 1}},
            {0, {1}}
        },
        {
            {1, 2, {5, 7, 3}},
            {0, {1}}
        },
        {
            {0, 2, {5, 8, 3}},
            {0, {1}}
        },
    } };
    assert(res.deg == mod.deg);
    for (int i = 0; i <= res.deg; i++) {
        assert(res.odds[i].num.sign == mod.odds[i].num.sign);
        for (int j = 0; j <= res.odds[i].num.deg; j++)
            assert(res.odds[i].num.arrOfNums[j] == mod.odds[i].num.arrOfNums[j]);
    }

    mod = modPPtoP(second , first);
    assert(second.deg == mod.deg);
    for (int i = 0; i <= second.deg; i++) {
        assert(second.odds[i].num.sign == mod.odds[i].num.sign);
        for (int j = 0; j <= second.odds[i].num.deg; j++)
            assert(second.odds[i].num.arrOfNums[j] == mod.odds[i].num.arrOfNums[j]);
    }

    return 0;
}
