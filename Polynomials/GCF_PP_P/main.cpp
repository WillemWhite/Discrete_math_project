/*
** НОД многочленов
** Зависимости:
** DEG_P_N
** MOD_PP_P
** (то есть при создании данного модуля должны использоваться функции этих модулей).
**
** В случае неимения решения модуля (в соответствующем проекте) на данный момент, прошу
** использовать в коде прототипы функций, что описал в header файле (все функции называются
** примерно также, как и модули).
**
** А как появится решение, можете скопировать код функции соответствующего проекта для
** своей  программы и протестировать ее на различные входные данные. С технологией
** тестирования определюсь позднее.
**
** Требование: оформлять функции (порядок аргументов и выходные данные) и использовать
** зависимые модули(если таковые есть) в точности с прототипом header файла
** (это сделано для стандартизации работы проекта).
**
** !!! В случае отсутствия у модуля каких-либо зависимостей необходимо сделать его
** как можно скорее и отправить на проверку !!!
**
** Желаю успехов, боец
** (-_-)
*/
#include <cassert>
#include "head.h"

LongP GCFofPPtoP(const LongP& P_dividend , const LongP& P_divider)
{
    LongP dividend = P_dividend , divider = P_divider;
    while (!(degPtoN(divider) == 0 && divider.odds[0].num.deg == 0 &&
        divider.odds[0].num.arrOfNums[0] == 0))
    {
        LongP temp = divider;
        divider = modPPtoP(dividend , divider);
        dividend = temp;
    }
    return dividend;
}

void tests()
{
    LongP test1 = { 0 };
    test1.deg = 1;
    test1.odds[0] = { {0, 0,{6}}, { 0,{1} }, };
    test1.odds[1] = { {0, 1,{1,1}}, { 0,{1} }, };

    LongP test2 = { 0 };
    test2.deg = 1;
    test2.odds[0] = { {0, 0,{8}}, { 0,{1} }, };
    test2.odds[1] = { {0, 1,{4,1}}, { 0,{1} }, };

    LongP resTest = { 0 };
    resTest.deg = 0;
    resTest.odds[0] = { {1, 0,{2}}, { 0,{7} }, };

    assert(comPPtoB(GCFofPPtoP(test1 , test2) , resTest));
}
int main()
{
    tests();
    return 0;
}
