#include <iostream>
#include "L_int.h"
#include "L_nat.h"
#include "L_pol.h"
#include "L_rat.h"

//=====================================================================================================================
/* COM_PP_B - Доп. модуль. Сергей Стукалов Гр. 0375
** --------------------------------------------------------------------------------------------------------------------
** Дополнительный модуль: сравнение многочленов.
** --------------------------------------------------------------------------------------------------------------------
*/
bool comPPtoB(const LongP& pol1 , const LongP& pol2)
{
    if (pol1.deg == pol2.deg)
    {
        int i = 0;
        while (comQQtoB(pol1.odds[i] , pol2.odds[i]) && i <= pol1.deg)
        {
            i++;
            continue;
        }
        if (i == pol1.deg + 1)
            return true;
        else
            return false;
    }
    else
        return false;
}
//=====================================================================================================================
/* ADD_PP_P - Виктор Яблоков Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** Сложение многочленов.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP addPPtoP(const LongP& polynomial1 , const LongP& polynomial2)
{
    LongP result = { 0 };
    if (polynomial1.deg > polynomial2.deg)
    {
        result = polynomial1;

        for (int i = 0; i <= polynomial2.deg; i++)
        {
            result.odds[i] = addQQtoQ(polynomial1.odds[i] , polynomial2.odds[i]);
        }
        //проверка на "зануление" последних степеней
        while (result.deg > 0 && !notZeroNtoB(absZtoN(result.odds[result.deg].num)))
            result.deg--;
    }
    else
    {
        result = polynomial2;

        for (int i = 0; i <= polynomial1.deg; i++)
        {
            result.odds[i] = addQQtoQ(polynomial1.odds[i] , polynomial2.odds[i]);
        }
        //проверка на "зануление" последних степеней
        while (result.deg > 0 && !notZeroNtoB(absZtoN(result.odds[result.deg].num)))
            result.deg--;
    }

    return result;
}
//=====================================================================================================================
/* SUB_PP_P - Степан Пилипченко Гр. 0375
** --------------------------------------------------------------------------------------------------------------------
** Вычитание многочленов.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP subPPtoP(const LongP& pol1 , const LongP& pol2)
{
    LongP invPol2 = pol2;

    for (int i = 0; i <= pol2.deg; i++)
    {
        invPol2.odds[i].num = mulZMtoZ(pol2.odds[i].num);
    }

    return addPPtoP(pol1 , invPol2);
}
//=====================================================================================================================
/* MUL_PQ_P - Степан Пилипченко Гр. 0375
** --------------------------------------------------------------------------------------------------------------------
** Умножение многочлена на рациональное число.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP mulPQtoP(const LongP& polynomial , const LongQ& number)
{
    LongP result = { 0 };
    result.deg = polynomial.deg;

    if (!notZeroNtoB(absZtoN(number.num)))
        return { 0 };

    for (int i = 0; i <= polynomial.deg; i++)
    {
        result.odds[i] = mulQQtoQ(polynomial.odds[i] , number);
    }

    return result;
}
//=====================================================================================================================
/* MUL_Pxk_P - Степан Пилипченко Гр. 0375
** --------------------------------------------------------------------------------------------------------------------
** Умножение многочлена на x^k.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP mulPxktoP(const LongP& polynomial , const int& k)
{
    LongP result = polynomial;

    if (k > 0)
    {
        // Увеличиваем степень многочлена на показатель степени x^k.
        result.deg += k;
        for (int i = result.deg; i >= k; i--)
        {
            // Переносим коэффициенты c i-ого на (i+k)-ое место.
            result.odds[i] = result.odds[i - k];

            // Зануляем элемент, из которого мы переносим число.
            // Для этого приравниваем числитель к 0, а знаменатель - к 1.
            result.odds[i - k].num = { 0,0,{0} };
            result.odds[i - k].denom = { 0,{1} };
        }

        for (int i = 0; i < k; ++i)
        {
            result.odds[i].num = { 0,0,{0} };
            result.odds[i].denom = { 0,{1} };
        }

        while (result.deg > 0 && !notZeroNtoB(absZtoN(result.odds[result.deg].num)))
            result.deg--;

        return result;
    }
    else if (k == 0)
        return result;
    else
    {
        std::cerr << "Error: k must be positive." << std::endl << std::endl;
        return { 0 };
    }
}
//=====================================================================================================================
/* LED_P_Q - Степан Пилипченко Гр. 0375
** --------------------------------------------------------------------------------------------------------------------
** Старший коэффициент многочлена.
** --------------------------------------------------------------------------------------------------------------------
*/
LongQ ledPtoQ(const LongP& polynomial)
{
    // Просто возвращаем коэффициент, индекс которого равен степени многочлена.
    return polynomial.odds[polynomial.deg];
}
//=====================================================================================================================
/* DEG_P_N - Мария Лукина Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** Степень многочлена.
** --------------------------------------------------------------------------------------------------------------------
*/
int degPtoN(const LongP& polynomial)
{
    return polynomial.deg; // выводим степень данного многочлена
}
//=====================================================================================================================
/* FAC_P_Q - Мария Лукина Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** Вынесение из многочлена НОК знаменателей коэффициентов и НОД числителей
** --------------------------------------------------------------------------------------------------------------------
*/
LongQ facPtoQ(LongP& polynomial)
{
    if (polynomial.deg == 0 && polynomial.odds[0].num.deg == 0 && polynomial.odds[0].num.arrOfNums[0] == 0)
    {
        std::cerr << "Error: polynomial cannot be zero." << std::endl << std::endl;
        return { 0 };
    }

    LongQ result = { 0 };

    result.denom = polynomial.odds[0].denom;

    for (int i = 1; i <= polynomial.deg; i++)
        result.denom = LCMofNNtoN(result.denom , polynomial.odds[i].denom);

    result.num = transNtoZ(absZtoN(polynomial.odds[0].num));
    for (int i = 1; i <= polynomial.deg; i++)
        result.num = transNtoZ(GCFofNNtoN(transZtoN(result.num) , absZtoN(polynomial.odds[i].num)));

    for (int i = 0; i <= polynomial.deg; i++)
        polynomial.odds[i] = divQQtoQ(polynomial.odds[i] , result);

    return result;
}
//=====================================================================================================================
/* MUL_PP_P - Александр Гирвиц Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** Умножение многочленов.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP mulPPtoP(const LongP& firstPol , const LongP& secondPol)
{
    LongP result = { 0 };

    result = mulPQtoP(secondPol , firstPol.odds[0]);
    for (int i = 1; i <= firstPol.deg; i++) {
        // i элеменет: a_i * x^i * (secondPol)
        LongP multiplication = mulPQtoP(mulPxktoP(secondPol , i) , firstPol.odds[i]);

        result = addPPtoP(multiplication , result);
    }

    // проверка на нули.
    while (result.deg > 0 && !notZeroNtoB(absZtoN(result.odds[result.deg].num)))
        result.deg--;

    return result;
}
//=====================================================================================================================
/* DIV_PP_P - Никита Бусько Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** Частное от деления многочлена на многочлен при делении с остатком.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP divPPtoP(const LongP& poly1 , const LongP& poly2)
{
    // копируем первый элемент для того, чтобы из него можно было вычитать.
    LongP copyPoly1 = poly1;
    LongP result = { 0 };
    // случай, когда можно делить (степень первого не меньше второго, иначе 0).
    if (degPtoN(poly1) >= degPtoN(poly2))
    {
        result.deg = degPtoN(poly1) - degPtoN(poly2);
        // для передвижения по массиву результата
        signed short int resDeg = result.deg;
        // пока не меньше степени делителя или! пока не 0
        // случай, если степень делителя равна 0
        while (degPtoN(copyPoly1) >= degPtoN(poly2) &&
            !(degPtoN(copyPoly1) == 0 &&
                copyPoly1.odds[0].num.deg == 0 &&
                copyPoly1.odds[0].num.arrOfNums[0] == 0))
        {
            LongQ coef = copyPoly1.odds[degPtoN(copyPoly1)];
            // коэффициент элемента результата
            result.odds[resDeg] = divQQtoQ(coef , poly2.odds[degPtoN(poly2)]);
            // передвигаемся дальше по элементам результата
            resDeg--;
            // вычитаем часть из первого
            copyPoly1 = subPPtoP(copyPoly1 ,
                mulPxktoP(mulPQtoP(poly2 , result.odds[resDeg + 1]) ,
                    degPtoN(copyPoly1) - degPtoN(poly2)));
        }

        return result;
    }
    else
    {
        return result; // если степень делителя больше делимого, то возвращаем {0}.
    }
}
//=====================================================================================================================
/* MOD_PP_P - Александр Гирвиц Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** Остаток от деления многочлена на многочлен при делении с остатком.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP modPPtoP(const LongP& first , const LongP& second)
{
    LongP quotient = divPPtoP(first , second);

    return subPPtoP(first , mulPPtoP(second , quotient));
}
//=====================================================================================================================
/* GCF_PP_P - Тигран Пипоян Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** НОД многочленов.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP GCFofPPtoP(const LongP& P_dividend , const LongP& P_divider)
{
    LongP dividend = P_dividend , divider = P_divider;
    while (!(degPtoN(divider) == 0 && divider.odds[0].num.deg == 0 &&
        divider.odds[0].num.arrOfNums[0] == 0))
    {
        LongP temp = divider;
        divider = modPPtoP(dividend , divider);
        dividend = temp;
    }
    return dividend;
}
//=====================================================================================================================
/* DER_P_P - Павел Рычков Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** Производная многочлена.
** --------------------------------------------------------------------------------------------------------------------
*/
LongP derPtoP(const LongP& polynomial)
{
    LongP result = polynomial;

    if (degPtoN(result) > 0)
    {
        for (signed short int i = 1; i <= degPtoN(result); ++i)
        {
            result.odds[i - 1] = mulQQtoQ(result.odds[i] , { {0, 0, {i}}, {0, {1}} });
        }

        result.odds[degPtoN(result)] = { 0 };
        result.deg--;

        return result;
    }
    else
        return { 0 };
}
//=====================================================================================================================
/* NMR_P_P - Тигран Пипоян Гр.0375
** --------------------------------------------------------------------------------------------------------------------
** Преобразование многочлена — кратные корни в простые
** --------------------------------------------------------------------------------------------------------------------
*/
LongP NMRofPtoP(const LongP& Polynom)
{
    if (degPtoN(Polynom) < 2)
    {
        return Polynom;
    }
    // если есть корень кратности k, то он есть в НОД многочлена и его производной
    // в виде кратности k - 1. Простой же корень не входит в этот НОД. Доказательство простое.
    LongP result = { 0 };

    LongP derp = derPtoP(Polynom);

    result = GCFofPPtoP(Polynom , derPtoP(Polynom));

    if (degPtoN(result) == 0)
    {
        return Polynom;
    }

    // в НОД может входить посторонный коэф. в виде m(x-1)^(k-1)*...
    // это получается из-за того, что кратность не гарантирует отсутствие констант в записи
    // поэтому используем ранее использованную функцию по выносу НОД и НОК (при этом изменяя сам аргумент
    // в виде полинома).
    facPtoQ(result);

    // блок кода, инвертирующий знаки, если старший коэффициент отрицателен.
    if (ledPtoQ(result).num.sign == 1)
    {
        for (int i = 0; i <= result.deg; ++i)
            result.odds[i].num = mulZMtoZ(result.odds[i].num);
    }

    return divPPtoP(Polynom , result);
}
//=====================================================================================================================
