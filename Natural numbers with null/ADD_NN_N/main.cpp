/*
** Сложение натуральных чисел
** Зависимости:
** COM_NN_D
** (то есть при создании данного модуля должны использоваться функции этих модулей).
**
** В случае неимения решения модуля (в соответствующем проекте) на данный момент, прошу
** использовать в коде прототипы функций, что описал в header файле (все функции называются
** примерно также, как и модули).
**
** А как появится решение, можете скопировать код функции соответствующего проекта для
** своей  программы и протестировать ее на различные входные данные. С технологией
** тестирования определюсь позднее.
**
** Требование: оформлять функции (порядок аргументов и выходные данные) и использовать
** зависимые модули(если таковые есть) в точности с прототипом header файла
** (это сделано для стандартизации работы проекта).
**
** !!! В случае отсутствия у модуля каких-либо зависимостей необходимо сделать его
** как можно скорее и отправить на проверку !!!
**
** Желаю успехов, боец
** (-_-)
*/
#include <cassert>
#include "head.h"

LongN addNNtoN(const LongN& n1 , const LongN& n2)
{
    LongN result = { 0,{0} };
    LongN naturalNumber1 = n1;
    LongN naturalNumber2 = n2;
    if (comNNtoD(naturalNumber1 , naturalNumber2) != 2)
    {
        for (int i = 0; i <= n2.deg; ++i)
        {
            //Следующая цифра заполняется делением на 10 суммы цифр предыдушего порядка.
            result.arrOfNums[i + 1] = ((n1.arrOfNums[i] + n2.arrOfNums[i] + result.arrOfNums[i]) / 10);

            //Цифра заполняется остатком от деления на 10 суммы цифр текущего порядка.
            result.arrOfNums[i] = (n1.arrOfNums[i] + n2.arrOfNums[i] + result.arrOfNums[i]) % 10;
        }
        if (result.arrOfNums[n2.deg + 1] != 0)
            result.deg = n2.deg + 1;
        else
            result.deg = n2.deg;
    }
    else
    {
        for (int i = 0; i <= n1.deg; ++i)
        {
            //Следующая цифра заполняется делением на 10 суммы цифр предыдушего порядка.
            result.arrOfNums[i + 1] = ((n1.arrOfNums[i] + n2.arrOfNums[i] + result.arrOfNums[i]) / 10);

            //Цифра заполняется остатком от деления на 10 суммы цифр текущего порядка.
            result.arrOfNums[i] = (n1.arrOfNums[i] + n2.arrOfNums[i] + result.arrOfNums[i]) % 10;
        }
        if (result.arrOfNums[n1.deg + 1] != 0)
            result.deg = n1.deg + 1;
        else
            result.deg = n1.deg;
    }
    return result;
}

int main()
{
    LongN n1 = { 10,{2,3,3,2,3,3,3,2,3,3,6} };
    LongN n2 = { 5,{1,2,5,3,2,5} };
    LongN n3 = { 10,{3,5,8,5,5,8,3,2,3,3,6} };
    LongN n4 = { 10,{4,7,3,9,7,3,4,2,3,3,6} };

    assert(comNNtoD(addNNtoN(n1 , n2) , n3) == 0);
    assert(comNNtoD(addNNtoN(n2 , n3) , n4) == 0);
}
