/*
** Умножение натуральных чисел
** Зависимости:
** MUL_ND_N
** MUL_Nk_N
** ADD_NN_N
** (то есть при создании данного модуля должны использоваться функции этих модулей).
**
** В случае неимения решения модуля (в соответствующем проекте) на данный момент, прошу
** использовать в коде прототипы функций, что описал в header файле (все функции называются
** примерно также, как и модули).
**
** А как появится решение, можете скопировать код функции соответствующего проекта для
** своей  программы и протестировать ее на различные входные данные. С технологией
** тестирования определюсь позднее.
**
** Требование: оформлять функции (порядок аргументов и выходные данные) и использовать
** зависимые модули(если таковые есть) в точности с прототипом header файла
** (это сделано для стандартизации работы проекта).
**
** !!! В случае отсутствия у модуля каких-либо зависимостей необходимо сделать его
** как можно скорее и отправить на проверку !!!
**
** Желаю успехов, боец
** (-_-)
*/
#include <cassert>
#include "head.h"

LongN mulNNtoN(const LongN& fNum , const LongN& sNum)
{
    LongN result = { 0,{0} };
    for (int i = 0; i <= sNum.deg; ++i)
    {
        result = addNNtoN(mulNktoN(mulNDtoN(fNum , sNum.arrOfNums[i]) , i) , result);
    }
    return result;
}

void mulNNtoNtests()
{
    const int testCount = 3;
    LongN tests[testCount][2] = { { {2, {1, 2, 1} }, {3, {4, 5, 3, 2} } }, { {0, {8} }, {0, {9} } }, { {4, {0, 0, 4, 3, 2} }, {1, {4, 5} } } }; // массив параметров
    LongN rtests[testCount] = { {5 , {4, 3, 8, 4, 8, 2} }, { 1, {2, 7} }, {6, {0, 0, 6, 3, 6, 2, 1} } }; // массив результатов
    for (int i = 0; i < testCount; ++i)
    {
        LongN result = mulNNtoN(tests[i][0] , tests[i][1]);
        assert(result.deg == rtests[i].deg); // проверка совпадения порядков
        for (int j = 0; j <= rtests[i].deg; ++j)
            assert(result.arrOfNums[j] == rtests[i].arrOfNums[j]); // проверка совпадения цифр 
    }
}

int main()
{
    mulNNtoNtests();
    return 0;
}
